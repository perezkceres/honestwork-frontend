{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useCallback, useState } from 'react';\nimport { getWeb3 } from 'utils/web3'; // it is called 2 times every fastRefresh (one for bid and one for win events)\n\nconst getPastEventsByBlocksStep = async (contract, eventName, // fromBlock = '0',\nfilter = {}, step = 5000) => {\n  const web3 = getWeb3();\n  const lastBlockNumber = await web3.eth.getBlockNumber(); // Just ignore fromBlock parameter which is hardcoded and casues issues on metamask when the number of calls increases\n  // let currentBlock = parseInt(fromBlock)\n  // go back to 5000 blocks instead (approx 5 minutes history) and collect that data\n  // with a step of 5000 it means that we have only 1 chunk\n\n  let currentBlock = lastBlockNumber - 5000;\n  const diff = lastBlockNumber - currentBlock;\n  if (diff <= 0) return [];\n  const chunks = [];\n\n  while (currentBlock < lastBlockNumber) {\n    chunks.push([currentBlock, Math.min(currentBlock + step, lastBlockNumber)]);\n    currentBlock += step;\n  } // console.log('chunks', chunks)\n\n\n  const events = await Promise.all(chunks.map(chunk => {\n    // console.log('call', chunk[0], chunk[1])\n    return contract.getPastEvents(eventName, {\n      filter,\n      fromBlock: chunk[0],\n      toBlock: chunk[1]\n    });\n  })).then(chunksData => {\n    let data = [];\n    chunksData.forEach(chunk => {\n      // console.log('single chung data', chunk)\n      data = data.concat(chunk);\n    });\n    return data;\n  });\n  return events;\n};\n\nconst usePastEvents = (contract, eventName, filter = undefined) => {\n  _s();\n\n  const [loading, setLoading] = useState(false);\n  const fetchEvents = useCallback(async () => {\n    setLoading(true);\n    let data = [];\n\n    try {\n      data = await getPastEventsByBlocksStep(contract, eventName, '6953142', filter);\n    } catch (e) {\n      console.error(e);\n    }\n\n    setLoading(false);\n    return data;\n  }, [contract, eventName, filter]);\n  return {\n    loading,\n    fetch: fetchEvents\n  };\n};\n\n_s(usePastEvents, \"JyOK80BOT8xMJVDIF5ldc9Ss8vI=\");\n\nexport default usePastEvents;","map":{"version":3,"sources":["/Users/ivopascoal/Desktop/SALSA/Salsa_frontend/src/hooks/usePastEvents.ts"],"names":["useCallback","useState","getWeb3","getPastEventsByBlocksStep","contract","eventName","filter","step","web3","lastBlockNumber","eth","getBlockNumber","currentBlock","diff","chunks","push","Math","min","events","Promise","all","map","chunk","getPastEvents","fromBlock","toBlock","then","chunksData","data","forEach","concat","usePastEvents","undefined","loading","setLoading","fetchEvents","e","console","error","fetch"],"mappings":";;AAAA,SAASA,WAAT,EAAsBC,QAAtB,QAAsC,OAAtC;AACA,SAASC,OAAT,QAAwB,YAAxB,C,CAEA;;AACA,MAAMC,yBAAyB,GAAG,OAChCC,QADgC,EAEhCC,SAFgC,EAGhC;AACAC,MAAW,GAAG,EAJkB,EAKhCC,IAAI,GAAG,IALyB,KAM7B;AACH,QAAMC,IAAI,GAAGN,OAAO,EAApB;AAIA,QAAMO,eAAuB,GAAG,MAAMD,IAAI,CAACE,GAAL,CAASC,cAAT,EAAtC,CALG,CAOH;AACA;AACA;AACA;;AACA,MAAIC,YAAY,GAAGH,eAAe,GAAG,IAArC;AAEA,QAAMI,IAAI,GAAGJ,eAAe,GAAGG,YAA/B;AACA,MAAIC,IAAI,IAAI,CAAZ,EAAe,OAAO,EAAP;AAEf,QAAMC,MAAM,GAAG,EAAf;;AAEA,SAAOF,YAAY,GAAGH,eAAtB,EAAuC;AACrCK,IAAAA,MAAM,CAACC,IAAP,CAAY,CAACH,YAAD,EAAeI,IAAI,CAACC,GAAL,CAASL,YAAY,GAAGL,IAAxB,EAA8BE,eAA9B,CAAf,CAAZ;AAEAG,IAAAA,YAAY,IAAIL,IAAhB;AACD,GAtBE,CAwBH;;;AACA,QAAMW,MAAa,GAAG,MAAMC,OAAO,CAACC,GAAR,CAC1BN,MAAM,CAACO,GAAP,CAAYC,KAAD,IAAW;AACpB;AACA,WAAOlB,QAAQ,CAACmB,aAAT,CAAuBlB,SAAvB,EAAkC;AACvCC,MAAAA,MADuC;AAEvCkB,MAAAA,SAAS,EAAEF,KAAK,CAAC,CAAD,CAFuB;AAGvCG,MAAAA,OAAO,EAAEH,KAAK,CAAC,CAAD;AAHyB,KAAlC,CAAP;AAKD,GAPD,CAD0B,EAS1BI,IAT0B,CASpBC,UAAD,IAAgB;AACrB,QAAIC,IAAI,GAAG,EAAX;AACAD,IAAAA,UAAU,CAACE,OAAX,CAAoBP,KAAD,IAAW;AAC5B;AACAM,MAAAA,IAAI,GAAGA,IAAI,CAACE,MAAL,CAAYR,KAAZ,CAAP;AACD,KAHD;AAIA,WAAOM,IAAP;AACD,GAhB2B,CAA5B;AAkBA,SAAOV,MAAP;AACD,CAlDD;;AAoDA,MAAMa,aAAa,GAAG,CAAC3B,QAAD,EAAWC,SAAX,EAA8BC,MAAW,GAAG0B,SAA5C,KAA0D;AAAA;;AAC9E,QAAM,CAACC,OAAD,EAAUC,UAAV,IAAwBjC,QAAQ,CAAC,KAAD,CAAtC;AACA,QAAMkC,WAAW,GAAGnC,WAAW,CAAC,YAAY;AAC1CkC,IAAAA,UAAU,CAAC,IAAD,CAAV;AACA,QAAIN,IAAI,GAAG,EAAX;;AACA,QAAI;AACFA,MAAAA,IAAI,GAAG,MAAMzB,yBAAyB,CAACC,QAAD,EAAWC,SAAX,EAAsB,SAAtB,EAAiCC,MAAjC,CAAtC;AACD,KAFD,CAEE,OAAO8B,CAAP,EAAU;AACVC,MAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACD;;AACDF,IAAAA,UAAU,CAAC,KAAD,CAAV;AACA,WAAON,IAAP;AACD,GAV8B,EAU5B,CAACxB,QAAD,EAAWC,SAAX,EAAsBC,MAAtB,CAV4B,CAA/B;AAYA,SAAO;AACL2B,IAAAA,OADK;AAELM,IAAAA,KAAK,EAAEJ;AAFF,GAAP;AAID,CAlBD;;GAAMJ,a;;AAoBN,eAAeA,aAAf","sourcesContent":["import { useCallback, useState } from 'react'\nimport { getWeb3 } from 'utils/web3'\n\n// it is called 2 times every fastRefresh (one for bid and one for win events)\nconst getPastEventsByBlocksStep = async (\n  contract: any,\n  eventName: string,\n  // fromBlock = '0',\n  filter: any = {},\n  step = 5000,\n) => {\n  const web3 = getWeb3()\n\n  \n\n  const lastBlockNumber: number = await web3.eth.getBlockNumber()\n\n  // Just ignore fromBlock parameter which is hardcoded and casues issues on metamask when the number of calls increases\n  // let currentBlock = parseInt(fromBlock)\n  // go back to 5000 blocks instead (approx 5 minutes history) and collect that data\n  // with a step of 5000 it means that we have only 1 chunk\n  let currentBlock = lastBlockNumber - 5000\n\n  const diff = lastBlockNumber - currentBlock\n  if (diff <= 0) return []\n\n  const chunks = []\n\n  while (currentBlock < lastBlockNumber) {\n    chunks.push([currentBlock, Math.min(currentBlock + step, lastBlockNumber)])\n\n    currentBlock += step\n  }\n\n  // console.log('chunks', chunks)\n  const events: any[] = await Promise.all(\n    chunks.map((chunk) => {\n      // console.log('call', chunk[0], chunk[1])\n      return contract.getPastEvents(eventName, {\n        filter,\n        fromBlock: chunk[0],\n        toBlock: chunk[1],\n      })\n    }),\n  ).then((chunksData) => {\n    let data = []\n    chunksData.forEach((chunk) => {\n      // console.log('single chung data', chunk)\n      data = data.concat(chunk)\n    })\n    return data\n  })\n\n  return events\n}\n\nconst usePastEvents = (contract, eventName: string, filter: any = undefined) => {\n  const [loading, setLoading] = useState(false)\n  const fetchEvents = useCallback(async () => {\n    setLoading(true)\n    let data = []\n    try {\n      data = await getPastEventsByBlocksStep(contract, eventName, '6953142', filter)\n    } catch (e) {\n      console.error(e)\n    }\n    setLoading(false)\n    return data\n  }, [contract, eventName, filter])\n\n  return {\n    loading,\n    fetch: fetchEvents,\n  }\n}\n\nexport default usePastEvents\n"]},"metadata":{},"sourceType":"module"}