import { __extends, __awaiter, __generator, __assign } from 'tslib';
import { AbstractConnector } from '@web3-react/abstract-connector';
import warning from 'tiny-warning';

function parseSendReturn(sendReturn) {
  return sendReturn.hasOwnProperty("result") ? sendReturn.result : sendReturn;
}

var NoBscProviderError =
/*#__PURE__*/

/** @class */
function (_super) {
  __extends(NoBscProviderError, _super);

  function NoBscProviderError() {
    var _this = _super.call(this) || this;

    _this.name = _this.constructor.name;
    _this.message = "No BSC provider was found on window.BinanceChain.";
    return _this;
  }

  return NoBscProviderError;
}(Error);

var UserRejectedRequestError =
/*#__PURE__*/

/** @class */
function (_super) {
  __extends(UserRejectedRequestError, _super);

  function UserRejectedRequestError() {
    var _this = _super.call(this) || this;

    _this.name = _this.constructor.name;
    _this.message = "The user rejected the request.";
    return _this;
  }

  return UserRejectedRequestError;
}(Error);

var BscConnector =
/*#__PURE__*/

/** @class */
function (_super) {
  __extends(BscConnector, _super);

  function BscConnector(kwargs) {
    var _this = _super.call(this, kwargs) || this;

    _this.handleNetworkChanged = _this.handleNetworkChanged.bind(_this);
    _this.handleChainChanged = _this.handleChainChanged.bind(_this);
    _this.handleAccountsChanged = _this.handleAccountsChanged.bind(_this);
    _this.handleClose = _this.handleClose.bind(_this);
    return _this;
  }

  BscConnector.prototype.handleChainChanged = function (chainId) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Handling 'chainChanged' event with payload", chainId);
    }

    this.emitUpdate({
      chainId: chainId,
      provider: window.BinanceChain
    });
  };

  BscConnector.prototype.handleAccountsChanged = function (accounts) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Handling 'accountsChanged' event with payload", accounts);
    }

    if (accounts.length === 0) {
      this.emitDeactivate();
    } else {
      this.emitUpdate({
        account: accounts[0]
      });
    }
  };

  BscConnector.prototype.handleClose = function (code, reason) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Handling 'close' event with payload", code, reason);
    }

    this.emitDeactivate();
  };

  BscConnector.prototype.handleNetworkChanged = function (networkId) {
    if (process.env.NODE_ENV !== "production") {
      console.log("Handling 'networkChanged' event with payload", networkId);
    }

    this.emitUpdate({
      chainId: networkId,
      provider: window.BinanceChain
    });
  };

  BscConnector.prototype.activate = function () {
    return __awaiter(this, void 0, void 0, function () {
      var account, error_1;
      return __generator(this, function (_a) {
        switch (_a.label) {
          case 0:
            if (!window.BinanceChain) {
              throw new NoBscProviderError();
            }

            if (window.BinanceChain.on) {
              window.BinanceChain.on("chainChanged", this.handleChainChanged);
              window.BinanceChain.on("accountsChanged", this.handleAccountsChanged);
              window.BinanceChain.on("close", this.handleClose);
              window.BinanceChain.on("networkChanged", this.handleNetworkChanged);
            }

            if (window.BinanceChain.isMetaMask) {
              window.BinanceChain.autoRefreshOnNetworkChange = false;
            }

            _a.label = 1;

          case 1:
            _a.trys.push([1, 3,, 4]);

            return [4
            /*yield*/
            , window.BinanceChain.send("eth_requestAccounts").then(function (sendReturn) {
              return parseSendReturn(sendReturn)[0];
            })];

          case 2:
            account = _a.sent();
            return [3
            /*break*/
            , 4];

          case 3:
            error_1 = _a.sent();

            if (error_1.code === 4001) {
              throw new UserRejectedRequestError();
            }

            process.env.NODE_ENV !== "production" ? warning(false, "eth_requestAccounts was unsuccessful, falling back to enable") : void 0;
            return [3
            /*break*/
            , 4];

          case 4:
            if (!!account) return [3
            /*break*/
            , 6];
            return [4
            /*yield*/
            , window.BinanceChain.enable().then(function (sendReturn) {
              return sendReturn && parseSendReturn(sendReturn)[0];
            })];

          case 5:
            // if enable is successful but doesn't return accounts, fall back to getAccount (not happy i have to do this...)
            account = _a.sent();
            _a.label = 6;

          case 6:
            return [2
            /*return*/
            , __assign({
              provider: window.BinanceChain
            }, account ? {
              account: account
            } : {})];
        }
      });
    });
  };

  BscConnector.prototype.getProvider = function () {
    return __awaiter(this, void 0, void 0, function () {
      return __generator(this, function (_a) {
        return [2
        /*return*/
        , window.BinanceChain];
      });
    });
  };

  BscConnector.prototype.getChainId = function () {
    return __awaiter(this, void 0, void 0, function () {
      var chainId, _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            if (!window.BinanceChain) {
              throw new NoBscProviderError();
            }

            _c.label = 1;

          case 1:
            _c.trys.push([1, 3,, 4]);

            return [4
            /*yield*/
            , window.BinanceChain.send("eth_chainId").then(parseSendReturn)];

          case 2:
            chainId = _c.sent();
            return [3
            /*break*/
            , 4];

          case 3:
            _a = _c.sent();
            process.env.NODE_ENV !== "production" ? warning(false, "eth_chainId was unsuccessful, falling back to net_version") : void 0;
            return [3
            /*break*/
            , 4];

          case 4:
            if (!!chainId) return [3
            /*break*/
            , 8];
            _c.label = 5;

          case 5:
            _c.trys.push([5, 7,, 8]);

            return [4
            /*yield*/
            , window.BinanceChain.send("net_version").then(parseSendReturn)];

          case 6:
            chainId = _c.sent();
            return [3
            /*break*/
            , 8];

          case 7:
            _b = _c.sent();
            process.env.NODE_ENV !== "production" ? warning(false, "net_version was unsuccessful, falling back to net version v2") : void 0;
            return [3
            /*break*/
            , 8];

          case 8:
            if (!chainId) {
              try {
                chainId = parseSendReturn(window.BinanceChain.send({
                  method: "net_version"
                }));
              } catch (_d) {
                process.env.NODE_ENV !== "production" ? warning(false, "net_version v2 was unsuccessful, falling back to manual matches and static properties") : void 0;
              }
            }

            if (!chainId) {
              if (window.BinanceChain.isDapper) {
                chainId = parseSendReturn(window.BinanceChain.cachedResults.net_version);
              } else {
                chainId = window.BinanceChain.chainId || window.BinanceChain.netVersion || window.BinanceChain.networkVersion || window.BinanceChain._chainId;
              }
            }

            return [2
            /*return*/
            , chainId];
        }
      });
    });
  };

  BscConnector.prototype.getAccount = function () {
    return __awaiter(this, void 0, void 0, function () {
      var account, _a, _b;

      return __generator(this, function (_c) {
        switch (_c.label) {
          case 0:
            if (!window.BinanceChain) {
              throw new NoBscProviderError();
            }

            _c.label = 1;

          case 1:
            _c.trys.push([1, 3,, 4]);

            return [4
            /*yield*/
            , window.BinanceChain.send("eth_accounts").then(function (sendReturn) {
              return parseSendReturn(sendReturn)[0];
            })];

          case 2:
            account = _c.sent();
            return [3
            /*break*/
            , 4];

          case 3:
            _a = _c.sent();
            process.env.NODE_ENV !== "production" ? warning(false, "eth_accounts was unsuccessful, falling back to enable") : void 0;
            return [3
            /*break*/
            , 4];

          case 4:
            if (!!account) return [3
            /*break*/
            , 8];
            _c.label = 5;

          case 5:
            _c.trys.push([5, 7,, 8]);

            return [4
            /*yield*/
            , window.BinanceChain.enable().then(function (sendReturn) {
              return parseSendReturn(sendReturn)[0];
            })];

          case 6:
            account = _c.sent();
            return [3
            /*break*/
            , 8];

          case 7:
            _b = _c.sent();
            process.env.NODE_ENV !== "production" ? warning(false, "enable was unsuccessful, falling back to eth_accounts v2") : void 0;
            return [3
            /*break*/
            , 8];

          case 8:
            if (!account) {
              account = parseSendReturn(window.BinanceChain.send({
                method: "eth_accounts"
              }))[0];
            }

            return [2
            /*return*/
            , account];
        }
      });
    });
  };

  BscConnector.prototype.deactivate = function () {
    if (window.BinanceChain && window.BinanceChain.removeListener) {
      window.BinanceChain.removeListener("chainChanged", this.handleChainChanged);
      window.BinanceChain.removeListener("accountsChanged", this.handleAccountsChanged);
      window.BinanceChain.removeListener("close", this.handleClose);
      window.BinanceChain.removeListener("networkChanged", this.handleNetworkChanged);
    }
  };

  BscConnector.prototype.isAuthorized = function () {
    return __awaiter(this, void 0, void 0, function () {
      var _a;

      return __generator(this, function (_b) {
        switch (_b.label) {
          case 0:
            if (!window.BinanceChain) {
              return [2
              /*return*/
              , false];
            }

            _b.label = 1;

          case 1:
            _b.trys.push([1, 3,, 4]);

            return [4
            /*yield*/
            , window.BinanceChain.send("eth_accounts").then(function (sendReturn) {
              if (parseSendReturn(sendReturn).length > 0) {
                return true;
              } else {
                return false;
              }
            })];

          case 2:
            return [2
            /*return*/
            , _b.sent()];

          case 3:
            _a = _b.sent();
            return [2
            /*return*/
            , false];

          case 4:
            return [2
            /*return*/
            ];
        }
      });
    });
  };

  return BscConnector;
}(AbstractConnector);

export { BscConnector, NoBscProviderError, UserRejectedRequestError };
//# sourceMappingURL=web3-connector.esm.js.map
